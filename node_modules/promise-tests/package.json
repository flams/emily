{
  "name": "promise-tests",
  "description": "A test suite for CommonJS Promises/A and related spec extensions",
  "version": "2.1.2",
  "author": {
    "name": "Domenic Denicola",
    "email": "domenic@domenicdenicola.com",
    "url": "http://domenicdenicola.com"
  },
  "license": "WTFPL",
  "repository": {
    "type": "git",
    "url": "git://github.com/domenic/promise-tests.git"
  },
  "bugs": {
    "url": "http://github.com/domenic/promise-tests/issues"
  },
  "main": "lib/programmaticRunner.js",
  "bin": {
    "promise-tests": "lib/cli.js"
  },
  "directories": {
    "lib": "lib"
  },
  "scripts": {
    "lint": "jshint lib"
  },
  "dependencies": {
    "mocha": ">= 1.6.0",
    "sinon": ">= 1.4.2",
    "prompt": ">= 0.2.7",
    "jquery-browserify": "*",
    "promise-stream": "*",
    "q": "*",
    "when": "*",
    "jsdom": ">= 0.2.18",
    "read-stream": "*"
  },
  "devDependencies": {
    "jshint": ">= 0.9.1"
  },
  "_dependencyComments": {
    "jquery-browserify": "this is the most straightforward translation of jQuery on npm",
    "jsdom": "for testing jQuery",
    "read-stream": "for testing promise-stream"
  },
  "readme": "# A Promises/A Test Suite\n\nInspired by [\"You're Missing the Point of Promises,\"][essay] I wrote this test suite for the [CommonJS Promises/A][]\nspec and some of its common extensions. If you're not passing this, something's wrong.\n\n\n[essay]: https://gist.github.com/3889970\n[CommonJS Promises/A]: http://wiki.commonjs.org/wiki/Promises/A\n\n## Deprecation Notice\n\n**This test suite is no longer maintained.** It has been superceded by the [Promises/A+ test suite][], which tests\nagainst the much better [Promises/A+ spec][]. That spec takes more care with various edge cases, and subsumes most of\nthe common extensions listed under \"Other Included Tests\" below. And the test suite is much more comprehensive, as well.\n\nNevertheless, the original README is left below for historical interest. But please, switch!\n\n[Promises/A+ test suite]: https://npmjs.org/package/promises-aplus-tests\n[Promises/A+ spec]: http://promises-aplus.github.com/promises-spec/\n\n---\n\n\n## How To Run\n\nThe tests run in a Node.js environment; make sure you have that installed.\n\n### Adapters\n\nIn order to test your promise library, you must expose a very minimal adapter interface. These are written as Node.js\nmodules with a few well-known exports. Check out some examples in `lib/adapters`, and read the `README.md` file there\nfor guidance and a more in-depth explanation.\n\n### From the CLI\n\nThis package comes with a command-line interface that can be used either by installing it globally with\n`npm install promise-tests -g` or by including it in your `package.json`'s `devDependencies` and using npm's `scripts`\nfeature. In the latter case, your setup might look something like\n\n```json\n{\n    \"devDependencies\": {\n        \"promise-tests\": \"*\"\n    },\n    \"scripts\": {\n        \"test\": \"run-my-own-tests && promise-tests all test/my-promise-tests-adapter\"\n    }\n}\n```\n\nThe CLI takes two arguments: the test suite you want to run (either `promises-a` or `all`), and the filename of your\nadapter file, relative to the current working directory. If either of these is missing, it will prompt you for them\ninteractively.\n\n### Programmatically\n\nThe main export of this package is a function that allows you to run the tests against an adapter:\n\n```js\nvar promiseTests = require(\"promise-tests\");\n\npromiseTests(adapter, [\"promises-a\"], function () {\n    // All done, output in the CLI.\n});\n```\n\nThe second parameter is an array containing which tests you want to run (see below).\n\n\n## Other Included Tests\n\nPromises/A is a rather bare spec. Most promise implementations have converged on certain semantics which make working\nwith promises much more pleasant. Those tests are included in other files in the `lib` directory, and can be run with\nthrough the CLI with the `all` option, or individually with the programmatic option.\n\n### Returning a Promise from a Handler\n\nThere is, unfortunately, a very common and important behavior of thenables that is *not* in the Promises/A spec: what\nhappens when one of your handlers returns a promise? For concreteness, let's use this example:\n\n```js\nvar a = b.then(function () {\n    return c; // `c` is a promise\n});\n```\n\nMost implementations have converged on the answer that `a` should be resolved in the same way as `c`, i.e.\n\n- `a` should be fulfilled if and only if `c` is fulfilled, and with `c`'s fulfillment value\n- `a` should be rejected if and only if `c` is rejected, and with `c`'s rejection reason\n\nUnfortunately the Promises/A spec alone seems to imply that `a` should always be fulfilled, with the promise `c` as its\nfulfillment value!\n\nTests for this spec extension are included as `returning-a-promise`.\n\n### Resolution Races\n\nAs described in the \"Requirements\" section of the [CommonJS wiki on Promises][wiki], number 3.2, you should be able to\ndistribute the resolver to multiple mutually-suspicious consumers, and have them \"race\" to resolve the promise. This is\nsomewhat analogous to the synchronous case where there can be a \"race\" between multiple `return` and `throw` statements\nwithin the same function. It's useful for implementing cases like a race between a timeout rejection and a normal\nresolution, as in Q's [`Q.timeout(promise, ms)`][timeout]. And it has some security implications in the\n[object-capability][] sense.\n\nIn particular, this means that resolvers (i.e. someone with only the ability to fulfill or reject a promise) should not\nbe able to observe the state of the promise so far. For example, attempting to resolve multiple times should not throw\nan error, since that would be a way for someone with only resolver capabilities to determine a promise's state. However,\nthe Promises/A spec itself failed to capture this requirement, even though the CommonJS group considered it important,\nso implementations are still Promises/A conforming if they throw errors.\n\nTests for this spec extension are included as `resolution-races`.\n\n\n[object-capability]: http://en.wikipedia.org/wiki/Object-capability_model\n[wiki]: http://wiki.commonjs.org/wiki/Promises\n[timeout]: https://github.com/kriskowal/q/blob/c2c7353dfa5341b1f57bd5f4c3ac40064bf3e63f/q.js#L1445-1465\n\n### Always Async\n\nIt's generally more predictable if you're guaranteed that your handlers are always called in a future turn of the event\nloop. This allows you to know the execution order of code like the following with confidence:\n\n```js\nconsole.log(\"1\");\n\npromise.then(function () {\n    console.log(\"3\");\n});\n\nconsole.log(\"2\");\n```\n\nIf a promise library does not guarantee asynchronicity, then in some cases the sequence will be 1, 2, 3, while in others\nit will be 1, 3, 2. This makes code hard to follow as your assumptions about what is true inside the handler do not\nalways hold.\n\nFor example, consider a promise-returning library for storing data that does not guarantee asynchronicity. You may be\nusing the `localStorage` backing store, which is always synchronous, leading you to expect the 1, 3, 2 sequence and\nwrite code that assumes changes were committed by the time 2 gets logged to the console. But later, you take advantage\nof this hypothetical library's great flexibility to switch to an `IndexedDB` backing store, which happens to be\nalways-asynchronous. Now your code takes the 1, 2, 3 path, breaking your earlier assumption and introducing tons of\nsubtle bugs.\n\nTo avoid this problem, leading promise libraries are sure to always call handlers in the next turn of the event loop,\nusing mechanisms like `process.nextTick` in Node or `setTimeout(..., 0)` in browsers. That way, promise producers can\nresolve their promises either synchronously or asynchronously, without worrying that promise consumers will face\ndifferent behavior.\n\nTests for this spec extension are included as `always-async`\n\n\n## Room for Improvement\n\nI'd like this to run more easily in the browser, for libraries like [Ember][] or jQuery (even though in the latter case\nI've hacked together a [jsdom][]-based solution).\n\nThere are other spec extensions that would be useful to test, e.g. the behavior of deferreds, which are more or less the\ncanonical promise-creation technique. There are a few subtleties there regarding resolving a deferred with a pending\npromise that not everyone gets right.\n\n\n[Ember]: https://github.com/emberjs/ember.js/commit/f7ac080db3a2a15f5814dc26fc86712cf7d252c8\n[jsdom]: https://github.com/tmpvar/jsdom\n",
  "readmeFilename": "README.md",
  "_id": "promise-tests@2.1.2",
  "dist": {
    "shasum": "6f3db0a455f12ec3a38a6d4889a9e46152165bfa"
  },
  "deprecated": "Use promises-aplus-tests instead.",
  "_from": "promise-tests"
}
