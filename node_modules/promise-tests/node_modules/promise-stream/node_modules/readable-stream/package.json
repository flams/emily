{
  "name": "readable-stream",
  "version": "0.0.2",
  "description": "An exploration of a new kind of readable streams for Node.js",
  "main": "readable.js",
  "dependencies": {},
  "devDependencies": {
    "tap": "~0.2.6"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/readable-stream"
  },
  "keywords": [
    "readable",
    "stream",
    "pipe"
  ],
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "license": "BSD",
  "readme": "# readable-stream\n\n    Stability: 1 - Experimental\n\nAn exploration of a new kind of readable streams for Node.js\n\nThis is an abstract class designed to be extended.  It also provides a\n`wrap` method that you can use to provide the simpler readable API for\nstreams that have the \"readable stream\" interface of Node 0.8 and\nbefore.\n\n## Usage\n\n```javascript\nvar Readable = require('readable-stream');\nvar r = new Readable();\n\nr.read = function(n) {\n  // your magic goes here.\n  // return n bytes, or null if there is nothing to be read.\n  // if you return null, then you MUST emit 'readable' at some\n  // point in the future if there are bytes available, or 'end'\n  // if you are not going to have any more data.\n  //\n  // You MUST NOT emit either 'end' or 'readable' before\n  // returning from this function, but you MAY emit 'end' or\n  // 'readable' in process.nextTick().\n};\n\nr.on('end', function() {\n  // no more bytes will be provided.\n});\n\nr.on('readable', function() {\n  // now is the time to call read() again.\n});\n```\n\n## Justification\n\nWritable streams in node are very straightforward to use and extend.\nThe `write` method either returns `true` if the bytes could be\ncompletely handled and another `write` should be performed, or `false`\nif you would like the user to back off a bit, in which case a `drain`\nevent at some point in the future will let them continue writing.  The\n`end()` method lets the user indicate that no more bytes will be\nwritten.  That's pretty much the entire required interface for\nwriting.\n\nHowever, readable streams in Node 0.8 and before are rather\ncomplicated.\n\n1. The `data` events start coming right away, no matter what.  There\n   is no way to do other actions before consuming data, without\n   handling buffering yourself.\n2. If you extend the interface in userland programs, then you must\n   implement `pause()` and `resume()` methods, and take care of\n   buffering yourself.\n\nSo, while writers only have to implement `write()`, `end()`, and\n`drain`, readers have to implement (at minimum):\n\n* `pause()` method\n* `resume()` method\n* `data` event\n* `end` event\n\nIf you are using a readable stream, and want to just get the first 10\nbytes, make a decision, and then pass the rest off to somewhere else,\nthen you have to handle buffering, pausing, and so on.  This is all\nrather brittle and easy to get wrong for all but the most trivial use\ncases.\n\nAdditionally, this all made the `reader.pipe(writer)` method\nunnecessarily complicated and difficult to extend without breaking\nsomething.  Backpressure and error handling is especially challenging\nand brittle.\n\n### Solution\n\nThe reader does not have pause/resume methods.  If you want to consume\nthe bytes, you call `read()`.  If bytes are not being consumed, then\neffectively the stream is in a paused state.  It exerts backpressure\non upstream connections, doesn't read from files, etc.\n\nIf `read()` returns `null`, then a future `readable` event will be\nfired when there are more bytes ready to be consumed.\n\nThis is simpler and conceptually closer to the underlying mechanisms.\nThe resulting `pipe()` method is much shorter and simpler.\n\n### Compatibility\n\nIt's not particularly difficult to wrap older-style streams in this\nnew interface, or to wrap this type of stream in the older-style\ninterface.\n\nThe `Readable` class takes an argument which is an old-style stream\nwith `data` events and `pause()` and `resume()` methods, and uses that\nas the data source.  For example:\n\n```javascript\nvar r = new Readable(oldReadableStream);\n\n// now you can use r.read(), and it will emit 'readable' events\n```\n\nThe `Readable` class will also automatically convert into an old-style\n`data`-emitting stream if any listeners are added to the `data` event.\nSo, this works fine, though you of course lose a lot of the benefits of\nthe new interface:\n\n```javascript\nvar r = new ReadableThing();\n\nr.on('data', function(chunk) {\n  // ...\n});\n\n// now pause, resume, etc. are patched into place, and r will\n// continually call read() until it returns null, emitting the\n// returned chunks in 'data' events.\n\nr.on('end', function() {\n  // ...\n});\n```\n",
  "readmeFilename": "README.md",
  "_id": "readable-stream@0.0.2",
  "_from": "readable-stream@0.0.2"
}
