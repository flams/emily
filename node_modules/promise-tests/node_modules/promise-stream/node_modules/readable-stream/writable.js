// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable

var util = require('util');
var Stream = require('stream');

util.inherits(Writable, Stream);

function Writable(options) {
  // buffer management
  this.length = 0;

  // the point at which write returns false
  this.highWaterMark = options.highWaterMark || 16 * 1024;

  // the point at which drain is emitted
  this.lowWaterMark = options.lowWaterMark || 1024;

  this._needDrain = false;
  this._ended = false;
  Stream.call(this);
}

// Override this method for sync streams
// override the _write(chunk, cb) method for async streams
Writable.prototype.write = function(chunk) {
  var ret = this.length >= this.highWaterMark;
  if (ret === false) {
    this._needDrain = true;
  }
  var l = chunk.length;
  this.length += l;
  this._write(chunk, function(er) {
    if (er) {
      this.emit('error', er);
      return;
    }
    this.length -= l;

    if (this.length === 0 && this._ended) {
      this.emit('end');
      return;
    }

    if (this.length < this.lowWaterMark && this._needDrain) {
      this._needDrain = false;
      this.emit('drain');
    }
  }.bind(this));
};

Writable.prototype._write = function(chunk, cb) {
  process.nextTick(cb.bind(this, new Error('not implemented')));
};

Writable.prototype.end = function(chunk) {
  if (chunk) {
    this.write(chunk);
  }
  this._ended = true;
};
