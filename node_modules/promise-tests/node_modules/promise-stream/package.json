{
  "name": "promise-stream",
  "version": "0.1.2",
  "description": "A Promises/A implementation based on streams",
  "keywords": [],
  "author": {
    "name": "Raynos",
    "email": "raynos2@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Raynos/promise-stream.git"
  },
  "main": "index",
  "homepage": "https://github.com/Raynos/promise-stream",
  "contributors": [
    {
      "name": "Jake Verbaten"
    }
  ],
  "bugs": {
    "url": "https://github.com/Raynos/promise-stream/issues",
    "email": "raynos2@gmail.com"
  },
  "dependencies": {
    "readable-stream": "0.0.2",
    "read-stream": "~0.4.5",
    "write-stream": "~0.4.1"
  },
  "devDependencies": {
    "tap": "~0.3.1",
    "read-write-stream": "~0.1.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/Raynos/promise-stream/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "test": "tap --stderr --tap ./test"
  },
  "readme": "# promise-stream\n\nA Promises/A implementation based on streams\n\nPromises and streams are the same thing. Except promises\nare far less powerful / flexible\n\n## Example using PromiseStream\n\n``` js\nvar ReadStream = require(\"read-stream\")\n    , assert = require(\"assert\")\n    , Promise = require(\"promise-stream\")\n\n// one is a queue\nvar one = ReadStream()\n    // Create a promise from one's stream.\n    , pone = Promise(one.stream)\n\nvar ptwo = pone.then(function (v) {\n    assert(true, \"one is fulfilled\")\n    console.log(\"one\", v)\n\n    return \"two\"\n}, function (e) {\n    assert(false, \"one is not rejected\")\n})\n\nvar pthree = ptwo.then(function (v) {\n    assert(true, \"two is fulfilled\")\n    console.log(\"two\", v)\n\n    throw \"three\"\n}, function (e) {\n    assert(false, \"two is not rejected\")\n})\n\nvar pfour = pthree.then(function (v) {\n    assert(false, \"three is not fulfilled\")\n}, function (e) {\n    assert(true, \"three is rejected\")\n    console.log(\"three\", e)\n})\n\n// Flow data through one's queue\none.end(\"one\")\n```\n\n## Same example using just streams\n\n``` js\nvar ReadWriteStream = require(\"read-write-stream\")\n    , assert = require(\"assert\")\n\nvar one = ReadWriteStream()\n    , two = ReadWriteStream(function write(chunk, queue) {\n        console.log(\"one\", chunk)\n        queue.push(\"two\")\n    })\n    , three = ReadWriteStream(function write(chunk, queue) {\n        console.log(\"two\", chunk)\n        queue.error(\"three\")\n    })\n    , four = ReadWriteStream()\n\nconnect([\n    one.stream\n    , two.stream\n    , three.stream\n    , four.stream\n]).on(\"error\", function (e) {\n    console.log(\"three\", e)\n})\n\n// Flow data through one's queu\none.end(\"one\")\n\n// Helper to emulate error propagation functionality\nfunction connect(streams) {\n    for (var i = 0; i < streams.length - 1; i++) {\n        var curr = streams[i]\n            , next = streams[i + 1]\n\n        curr.pipe(next)\n\n        // In an ideal world you just use domains.\n        // None of this error propagation stuff.\n        curr.on(\"error\", function (err) {\n            next.emit(\"error\", err)\n        })\n    }\n\n    return next\n}\n```\n\n## Installation\n\n`npm install promise-stream`\n\n## Contributors\n\n - Raynos\n\n## MIT Licenced\n",
  "_id": "promise-stream@0.1.2",
  "_from": "promise-stream@*"
}
