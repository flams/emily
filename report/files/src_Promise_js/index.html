<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap-3.0.0-wip.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>src/Promise.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="span6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">75.98</p>
    </div>
    <div class="span6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">260</p>
    </div>
  </div>
  <div class="row historical">
    <div class="span6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="span6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="span6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">33.03</p>
    </div>
    <div class="span6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">0.93</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="span6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="span6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="span12">/**
 * Emily
 * Copyright(c) 2012-2013 Olivier Scherrer <pode.fr@gmail.com>
 * MIT Licensed
 */
define(["Observable", "StateMachine"],

/**
 * @class
 * Create a promise/A+
 */
function Promise(Observable, StateMachine) {

    return function PromiseConstructor() {

        /**
         * The fulfilled value
         * @private
         */
        var _value = null,

        /**
         * The rejection reason
         * @private
         */
        _reason = null,

        /**
         * The funky observable
         * @private
         */
        _observable = new Observable(),

        /**
         * The state machine States & transitions
         * @private
         */
        _states = {

            // The promise is pending
            "Pending": [

                // It can only be fulfilled when pending
                ["fulfill", function onFulfill(value) {
                    _value = value;
                    _observable.notify("fulfill", value);
                // Then it transits to the fulfilled state
                }, "Fulfilled"],

                // it can only be rejected when pending
                ["reject", function onReject(reason) {
                    _reason = reason;
                    _observable.notify("reject", reason);
                // Then it transits to the rejected state
                }, "Rejected"],

                // When pending, add the resolver to an observable
                ["toFulfill", function toFulfill(resolver) {
                    _observable.watch("fulfill", resolver);
                }],

                // When pending, add the resolver to an observable
                ["toReject", function toReject(resolver) {
                    _observable.watch("reject", resolver);
                }]],

            // When fulfilled,
            "Fulfilled": [
                // We directly call the resolver with the value
                ["toFulfill", function toFulfill(resolver) {
                    setTimeout(function () {
                        resolver(_value);
                    }, 0);
                }]],

            // When rejected
            "Rejected": [
                // We directly call the resolver with the reason
                ["toReject", function toReject(resolver) {
                    setTimeout(function () {
                        resolver(_reason);
                    }, 0);
                }]]
        },

        /**
         * The stateMachine
         * @private
         */
        _stateMachine = new StateMachine("Pending", _states);

        /**
         * Fulfilled the promise.
         * A promise can be fulfilld only once.
         * @param the fulfillment value
         * @returns the promise
         */
        this.fulfill = function fulfill(value) {
            _stateMachine.event("fulfill", value);
            return this;
        };

        /**
         * Reject the promise.
         * A promise can be rejected only once.
         * @param the rejection value
         * @returns true if the rejection function was called
         */
        this.reject = function reject(reason) {
            _stateMachine.event("reject", reason);
            return this;
        };

        /**
         * The callbacks to call after fulfillment or rejection
         * @param {Function} fulfillmentCallback the first parameter is a success function, it can be followed by a scope
         * @param {Function} the second, or third parameter is the rejection callback, it can also be followed by a scope
         * @examples:
         *
         * then(fulfillment)
         * then(fulfillment, scope, rejection, scope)
         * then(fulfillment, rejection)
         * then(fulfillment, rejection, scope)
         * then(null, rejection, scope)
         * @returns {Promise} the new promise
         */
        this.then = function then() {
            var promise = new PromiseConstructor();

            // If a fulfillment callback is given
            if (arguments[0] instanceof Function) {
                // If the second argument is also a function, then no scope is given
                if (arguments[1] instanceof Function) {
                    _stateMachine.event("toFulfill", this.makeResolver(promise, arguments[0]));
                } else {
                    // If the second argument is not a function, it's the scope
                    _stateMachine.event("toFulfill", this.makeResolver(promise, arguments[0], arguments[1]));
                }
            } else {
                // If no fulfillment callback given, give a default one
                _stateMachine.event("toFulfill", this.makeResolver(promise, function () {
                    promise.fulfill(_value);
                }));
            }

            // if the second arguments is a callback, it's the rejection one, and the next argument is the scope
            if (arguments[1] instanceof Function) {
                _stateMachine.event("toReject", this.makeResolver(promise, arguments[1], arguments[2]));
            }

            // if the third arguments is a callback, it's the rejection one, and the next arguments is the sopce
            if (arguments[2] instanceof Function) {
                _stateMachine.event("toReject", this.makeResolver(promise, arguments[2], arguments[3]));
            }

            // If no rejection callback is given, give a default one
            if (!(arguments[1] instanceof Function) &&
                !(arguments[2] instanceof Function)) {
                _stateMachine.event("toReject", this.makeResolver(promise, function () {
                    promise.reject(_reason);
                }));
            }

            return promise;
        };

        /**
         * Synchronize this promise with a thenable
         * @returns {Boolean} false if the given sync is not a thenable
         */
        this.sync = function sync(syncWith) {
            if (syncWith instanceof Object && syncWith.then) {

                var onFulfilled = function onFulfilled(value) {
                    this.fulfill(value);
                },
                onRejected = function onRejected(reason) {
                    this.reject(reason);
                };

                syncWith.then(onFulfilled.bind(this),
                        onRejected.bind(this));

                return true;
            } else {
                return false;
            }
        };

        /**
         * Make a resolver
         * for debugging only
         * @private
         * @returns {Function} a closure
         */
        this.makeResolver = function makeResolver(promise, func, scope) {
            return function resolver(value) {
                var returnedPromise;

                try {
                    returnedPromise = func.call(scope, value);
                    if (!promise.sync(returnedPromise)) {
                        promise.fulfill(returnedPromise);
                    }
                } catch (err) {
                    promise.reject(err);
                }

            };
        };

        /**
         * Returns the reason
         * for debugging only
         * @private
         */
        this.getReason = function getReason() {
            return _reason;
        };

        /**
         * Returns the reason
         * for debugging only
         * @private
         */
        this.getValue = function getValue() {
            return _value;
        };

        /**
         * Get the promise's observable
         * for debugging only
         * @private
         * @returns {Observable}
         */
        this.getObservable = function getObservable() {
            return _observable;
        };

        /**
         * Get the promise's stateMachine
         * for debugging only
         * @private
         * @returns {StateMachine}
         */
        this.getStateMachine = function getStateMachine() {
            return _stateMachine;
        };

        /**
         * Get the statesMachine's states
         * for debugging only
         * @private
         * @returns {Object}
         */
        this.getStates = function getStates() {
            return _states;
        };

    };




});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
